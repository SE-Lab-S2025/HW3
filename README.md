# HW3
Test-Driven Development

## پاسخ به پرسش‌های بخش اول

### پرسش اول
**سوال:** در این که چه خطایی وجود دارد؟ و به نظر شما چرا دیده نشده است؟ (در دو خط توضیح دهید)

**پاسخ:**
خطای موجود این است که متد `calculateBalance` اجازه می‌دهد برداشت از حساب منجر به موجودی منفی شود، که این برخلاف قوانین تعریف‌شده‌ی برنامه است.  
این خطا در تست‌های اولیه دیده نشده بود زیرا هیچ‌کدام از موارد آزمون (Test Cases) سناریویی را پوشش نمی‌دادند که در آن مبلغ برداشت از موجودی فعلی حساب بیشتر باشد.

### پرسش دوم

**وظیفه:** پس از یافتن خطا، یک آزمون برای آن بنویسید که منجر به کشف آن خطا شود. سپس آن را به گونه ای اصلاح کنید که آن مورد آزمون پاس شود.

**گزارش انجام کار:**

مطابق با دستورالعمل، ابتدا یک تست جدید به نام `testWithdrawalExceedingBalanceShouldThrowException` نوشته شد تا خطای مربوط به امکان منفی شدن موجودی را شناسایی کند. این فرآیند طبق چرخه‌ی TDD انجام شد.

**1. نتیجه اجرای تست پیش از اعمال تغییرات (حالت قرمز - RED):**

در این مرحله، تست نوشته‌شده برای باگ اجرا گردید. همانطور که مشاهده می‌شود، تست با شکست مواجه شد زیرا کد اصلی، خطای مورد انتظار (`IllegalArgumentException`) را در زمان برداشت غیرمجاز پرتاب نمی‌کند.

![نتیجه تست ناموفق](report-images/1.png)

**2. تغییرات اعمال‌شده در کد اصلی:**

برای رفع این مشکل و پاس شدن تست، یک شرط به متد `calculateBalance` اضافه شد تا پیش از هر عملیات برداشت، کافی بودن موجودی را بررسی کند و در صورت عدم موجودی کافی، یک خطا پرتاب نماید.

![کد اعمال شده برای رفع خطا](report-images/2.png)

**3. نتیجه اجرای تست پس از اعمال تغییرات (حالت سبز - GREEN):**

پس از اعمال تغییرات در کد، همان تست مجدداً اجرا شد و این بار با موفقیت پاس گردید. این نشان می‌دهد که باگ با موفقیت برطرف شده و عملکرد برنامه مطابق با نیازمندی‌ها است.

![نتیجه تست موفق](report-images/3.png)

### پرسش سوم
**سوال:** بنظر شما و بر اساس تجربه ی بدست آمده نوشتن آزمون پس از نوشتن برنامه چه مشکلاتی را میتواند بسازد؟ (در سه خط توضیح دهید)

**پاسخ:**
نوشتن آزمون پس از تکمیل کد، این ریسک را ایجاد می‌کند که تست‌ها تنها مسیرهای موفق (Happy Paths) را پوشش دهند و موارد مرزی و خطاها (مانند باگ موجودی منفی) نادیده گرفته شوند، زیرا توسعه‌دهنده به صورت ناخودآگاه تمایل به تأیید کدی دارد که نوشته است.

همچنین، کدی که بدون در نظر گرفتن آزمون‌پذیری نوشته می‌شود، ممکن است به گونه‌ای طراحی شود که تست کردن آن در آینده دشوار یا غیرممکن باشد و نیازمند بازنویسی (Refactoring) گسترده گردد.

در نهایت، این رویکرد می‌تواند منجر به پوشش آزمون (Test Coverage) پایین و ناقص شود، زیرا ممکن است توسعه‌دهنده فراموش کند برای تمام منطق‌ها و قابلیت‌های پیاده‌سازی‌شده، تست کافی بنویسد.

## پاسخ پرسش‌های بخش دوم
<div dir="rtl">
تست‌ها را به ترتیب بررسی می‌کنیم. تست‌های اول و دوم با فراخوانی <code>addTransaction(t)</code> در متد <code>calculateBalance</code> پاس می‌شوند.
تست سوم حذف شدن تاریخچه‌ی محاسبات قبلی را بررسی می‌کند که با فراخوانی <code>clearTransactionHistory</code> قبل از انجام محاسبات در همان متد پاس می‌شود.
</div>

<div dir="rtl">

### پاسخ پرسش چهارم


* تست‌ها دقیقاً گفتند چه رفتاری می‌خواهیم:

  * لیست خالی ⇒ موجودی ۰ (`testEmptyTransactionList`).
  * فقط واریز ⇒ جمع ارقام (`testOnlyDeposits`).
  * ترکیبی واریز/برداشت ⇒ جمع و تفریق درست (`testMixedTransactions`).
  * مبلغ صفر ⇒ اثری روی موجودی نداشته باشد (`testZeroAmountTransaction`).
* درباره‌ی تاریخچه هم تکلیف روشن شد:

  * اول کار تاریخچه باید خالی باشد (`testTransactionHistoryShouldBeEmptyBeforeCalculatingBalance`).
  * بعد از محاسبه، همان تراکنش‌های همان محاسبه در تاریخچه ثبت شوند (`testTransactionHistoryAfter...`).
  * با هر بار محاسبه، تاریخچهٔ قبلی پاک و فقط «آخرین» تراکنش‌ها بمانند (`testTransactionHistoryShouldContainOnlyLastCalculationTransactions`).
    همین باعث شد در ابتدای `calculateBalance`، `clearTransactionHistory()` را صدا بزنیم و داخل حلقه هر تراکنش را با `addTransaction` ثبت کنیم.
* تست‌ها مثل چراغ راه بودند: هر تغییری می‌دادم، فوری می‌فهمیدم درست است یا نه؛ حدس و گشتنِ بی‌هدف کم شد.
* برای خطاهای رایج هم حساس شدم (مثل برداشت بیشتر از موجودی) و چک ساده‌ای گذاشتم تا اشتباه رد نشود.

### پاسخ پرسش پنجم


**مزایا**

* رفتار سیستم از اول شفاف شد (صفرها، جمع/تفریق، و مخصوصاً سیاست تاریخچه).
* باگ‌ها زود پیدا می‌شوند و برنمی‌گردند؛ تست‌ها نقش «تور ایمنی» دارند.
* تغییرات کوچک و مطمئن انجام می‌شود؛ هر قدم سبز شدنی است.
* تست‌ها مثل مستند زنده‌اند؛ هرکس کد را می‌بیند، از روی تست‌ها می‌فهمد انتظار چیست.
* زمان دیباگ کم می‌شود چون سریع معلوم می‌شود ایراد کجاست.

**معایب / سختی‌ها**

* شروع کار زمان‌برتر است؛ باید قبل از کد، سناریوها را به تست تبدیل کنیم.
* با تغییر نیازمندی، تست‌ها هم باید آپدیت شوند.
* وجود وضعیت سراسری/ایستا (مثل `transactionHistory`) می‌تواند دردسرساز شود و باید حواس‌مان به پاک‌سازی و ترتیب اجرا باشد.
* اگر تست‌ها بد نوشته شوند، حس امنیتِ الکی می‌دهند؛ باز هم نیاز به بازبینی کد و چند نوع تست دیگر داریم.

**جمع‌بندی کوتاه:**
TDD کمک کرد قواعد اصلی و رفتار تاریخچه را دقیق کنیم و بدون ترس تغییر بدهیم؛ در عوض، اول کار کمی کندتر شد و باید با حوصله تست‌ها را نگه‌داری و وضعیت سراسری را مدیریت کنیم.

</div>


